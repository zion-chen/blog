---
title: 数据库系统期末复习
date: 2023-2-28 00:00:00
tags: 
  - 数据库
  - 复习
categories: 期末复习
description: 应付数据库考试写的复习资料
cover: https://pic.imgdb.cn/item/656af6b9c458853aef131025.png
katex: true
---
## 选择题
### 数据抽象
- **物理层**描述数据实际上是怎么储存的，描述复杂的底层数据结构。
  例如数据在计算机内部是字节组成的存储块。
  也叫**内模式**、存储模式
- **逻辑层**描述数据库中储存什么数据以及这些数据间存在什么关系。
  例如如果选择关系模型存储数据，则程序员编写SQL语句来存储数据。
  也叫**模式**、逻辑模式
- **视图层**只描述数据库的某个部分。
  例如用户只需要看到数据库的一部分输出内容。
  也叫**外模式**、子模式、用户模式
### 数据模型
- 关系模型（SQL）
- 实体-联系模型（E-R）
- 基于对象数据模型
- 网状数据模型（偏底层）
- 层次数据模型（偏底层）
### B+树
- 非根非叶子结点有 $[n/2]$ 到 $n$ 个孩子
- 叶子结点有 $[(n-1)/2]$ 到 $n-1$ 个值
- 根结点（非叶子结点）最少有 $2$ 个孩子
- 根节点（叶子结点）有 $0$ 到 $n-1$ 个值
### 事务
#### 事务的性质（ACID）
- 原子性
  事务的所有操作在数据库中要么成功，要么失败
- 一致性
  保持数据库中某些属性在事务完成后不变（具体业务具体分析）
- 隔离性
  每个事务感受不到有其他事务在并发执行
- 持久性
  一个事务成功完成后，对数据库的改变是永久的
#### 调度隔离级别
1. Read uncommitted(读未提交)
   如果一个事务已经开始写数据，则另外一个事务不允许同时进行写操作，但允许其他事务读此行数据
   就是一个事务可以读取另一个未提交事务的数据
2. Read committed(读提交)
   如果是一个读事务(线程)，则允许其他事务读写，如果是写事务将会禁止其他事务访问该行数据
   就是只能读到已经提交了的内容
3. Repeatable read(可重复读取)
   可重复读取是指在一个事务内，多次读同一个数据，在这个事务还没结束时，其他事务不能访问该数据(包括了读写)
4. Serializable(串行化)
   提供严格的事务隔离，它要求事务序列化执行，事务只能一个接着一个地执行，不能并发执行
#### 2NL
- **增长阶段**：事务可以获得锁，但不能释放锁
- **收缩阶段**：事务可以释放锁，但不能获得锁
   简单来说，一旦获得锁就进入增长阶段，之后一旦释放锁就进入收缩阶段
- 一个事务开始时就全部上锁，结束时再全部释放锁
- 2NL协议可以确保冲突可串行化
- 2NL协议可能会**导致死锁**
#### 基于日志的恢复
- redo：使未完成的完成
  根据已有的日志继续进行，不会产生新日志
- undo：使未完成的停止
  会写新日志
## 关系代数
### 关系代数的基本操作
|操作|符号|
|:-:|:-:|
|选择|$\sigma$|
|投影|$\Pi$|
|并|$\cup$|
|集合差|$-$|
|笛卡尔积|$\times$|
|重命名|$\rho$|
### 关系代数的附加操作
|操作|符号|
|:-:|:-:|
|集合交|$\cap$|
|自然连接|$\Join$|
|除法|$\div$|

除法举例：给定关系 $R(X,Y)$ 和 $S(Y,Z)$ ， $R$ 中的 $Y$ 和 $S$ 中的 $Y$ 同域，则 $R \div S$ 意为“得到两关系 $Y$ 属性值相同的 $X$ 属性值集合”
## SQL
### 创建表
```SQL
CREAT TABLE work (
   name VARCHAR(10) PRIMARY KEY,
   salary DECIMAL(10,2),
   company_name VARCHAR(20),
   FOREIGN KEY company_name REFERENCES company(company_name)
);
```
### 修改表
```SQL
# 给表中新增属性
ALTER TABLE work
ADD city VARCHAR(20);
# 删除表中属性
ALTER TABLE work
DROP COLUMN city;
```
### 插入数据
```SQL
INSERT INTO work
('name','salary','company_name')
VALUES
('Mike','1000.00','AMD');
```
### 更新数据
```SQL
UPDATE work
SET comapny_name = 'INTEL'
WHERE name = 'Mike';
```
### 查询数据
#### 聚合函数
- `COUNT(col)` 返回此列符合条件的行数
  `COUNT(*)` 返回表中行数
- `AVG(col)` 返回此数值列的平均值
- `SUM(col)` 返回此数值列的总和
聚合函数不能用在`WHERE`语句中，只能用在`SELECT`和`HAVING`中
#### GOURP BY 和 HAVING
`GROUP BY col` 按此属性对查询的另一属性分组
```SQL
# 按city分组，查询每个“至少有两位员工的城市”中有多少位员工
SELECT COUNT(name), city
FROM work
GROUP BY city
HAVING COUNT(name) >= 2;
```
套路是：查询两列，其中一列用来分组，另一列用来计算
### 视图的创建
```SQL
CREATE VIEW emplyee_in_NewYork AS
SELECT name, salary
FROM work
WHERE city = 'NewYork';
```
## 关系理论
### 码的概念
|概念|描述|
|:-:|:-:|
|码（超码）|能够**唯一标识**一条记录的属性或属性集|
|候选码|能够**唯一标识**一条记录的**最小属性集**|
|主码|**某个**能够**唯一标识**一条记录的**最小属性集**（是从候选码里人为挑选的一条）|
|主属性|包含在任一候选码中的属性称主属性。简单来说，主属性集是**候选码所有属性的并集**|
|非主属性|不包含在候选码中的属性|
### 依赖
简单来说就是，若属性X的属性值一样（$X_1=X_2$），则属性Y中的属性值就一样（$Y_1=Y_2$），那么 $Y$ 依赖于 $X$ ，即 $X\rightarrow Y$。例如：学号决定了姓名，学号相同则姓名必然相同，那么姓名就依赖于学号。
|概念|描述|
|:-:|:-:|
|平凡依赖|$Y$ 是 $X$ 的子集。例如： $ABC\rightarrow B$|
|非平凡依赖|$Y$ 不是 $X$ 的子集|
|完全依赖|例如：学号，课程号可以推出成绩，而只有学号或者课程号就推不出成绩，则**成绩**完全依赖于**学号，课程号**|
|部分依赖|例如：学号，课程号可以推出姓名，而只有学号也可以推出姓名，则**姓名**部分依赖于**学号，课程号**|
|传递依赖|例如：学号可以推出姓名，姓名可以推出姓氏，则**姓氏**传递依赖于**学号**|
### 闭包
闭包就是由一个属性直接或间接推导出的所有属性的集合。  
例如：$F=\{a\rightarrow b,b\rightarrow c,a\rightarrow d,e\rightarrow f\}$ ，由 $a$ 可直接得到 $b$ 和 $d$ ，间接得到 $c$ ，则 $a$ 的闭包就是 $(a)^+_F=\{a,b,c,d\}$。
### 范式
#### 1NF
- 所有属性都是不可分割的数据项。  
- 如果某个属性，例如学校，还可以继续拆分为高中和大学，就不满足1NF了。  
- 1NF是关系数据库需要满足的最低要求。
#### 2NF
- 在满足1NF的前提下，不包含非主属性对码的部分函数依赖（即每一个非主属性都完全函数依赖于码）。  
- 例如在关系R中，码是学号和班级，非主属性是姓名，因为通过学号就能直接推出姓名了，不需要班级，此处姓名就部分依赖于码了，不满足2NF。  
- 例：若码是 $AB$ ，$F=\{A\rightarrow C, AB\rightarrow D\}$ ，对于 $C$ ，只需要 $A$ 就能推出，那么 $C$ 部分函数依赖于码 $AB$ ，这种情况就不是2NF。  
若要分解为2NF，只需将不符合要求的拿出来，即分为 $R_1\{A, B, D\}$ 和 $R_2\{A, C\}$。
#### 3NF
- 在满足2NF的前提下，不包含**非主属性**对码的传递函数依赖（即码应该直接决定非主属性，不能间接决定）。  
- 例如在关系R中，码是客户姓名，非主属性是订单编号和订单负责人，通过客户姓名可以推出他的订单编号，再通过订单编号能推出订单负责人，这种情况下客户姓名和订单负责人是间接决定的，存在传递函数依赖，不满足3NF。  
- 例：若码是 $AB$ ，$F=\{AB\rightarrow C, C\rightarrow D\}$ ，这里不存在部分函数依赖。但是对于 $D$ ，需要 $AB$ 推出 $C$ 后才能间接推出 $D$ ，那么 $D$ 传递函数依赖于 $AB$ ，不满足3NF。  
若要分解为3NF，同样将不符合要求的拿出来，即分为 $R_1\{A,B,C\}$ 和 $R_2\{C, D\}$。
#### BCNF
- 消除**任何属性**对候选码的传递依赖，即每一个决定因素都包含码，表现为在函数依赖集当中，左边的都包含候选码。  
- 例：若 $R=(A,B,C)$，$F=\{AC\rightarrow B,AB\rightarrow C,B\rightarrow C\}$，候选码则是 $AC$ 和 $AB$ 。这里**不存在非主属性**的部分函数依赖，但对于 $B\rightarrow C$ 来说，决定因素 $B$ 不包含码，因此它不是BCNF。
### 考题
#### 求候选码
1. 观察函数依赖，只出现在左边的一定属于候选码，只出现在右边的一定不属于候选码，两边都出现的有可能是候选码
2. 对只出现在左边的求闭包，如果可以推出全部属性则加入候选码，如果不能则和可能属于候选码的属性进行组合求闭包
#### 范式级别判断
1. 求候选码
2. 写出非主属性、候选码
   非主属性就是未出现在候选码中的属性
3. 判断2NF（判断非主属性部分依赖）:
   观察**非主属性**的左侧是否**完整**出现了任一候选码（非主属性必须由完整的任一候选码推出），若是则符合2NF
4. 判断3NF（判断非主属性传递依赖）：
   观察所有非主属性是否是由候选码直接推出，若是则符合3NF
5. 判断BCNF
   观察每个函数依赖左侧是否包含任一候选码，若是则符合BCNF
#### 求最小依赖集
1. 拆分右侧
    - 例如将 $A\rightarrow BC$ 拆为 $A\rightarrow B$ 和 $A\rightarrow C$
2. 去除自身求闭包
    - 若有$AB\rightarrow C$，$BC\rightarrow E$，$AE\rightarrow G$，去除 $AB$ 自身能推出的 $C$ ，基于剩余的依赖关系求 $AB$ 的闭包，若 $AB$ 通过剩余的关系也能求出 $C$ ，那么删除 $AB\rightarrow C$ 这个依赖关系
3. 左侧最小化
    - 例如目前保留的关系有 $ABC\rightarrow D$ ，观察左边的 $ABC$ 当中，$A$ 是否能由 $BC$ 推出，$B$ 是否能由 $AC$ 推出，$C$ 是否能由 $AB$ 推出。假设 $C$ 能被 $AB$ 推出，那么左侧去掉 $C$，更新为 $AB\rightarrow D$
#### 3NF分解
设有属性集 $U$，函数依赖集 $F$，其模式分解后应得到多个 $U$ 的子集
1. 求出最小函数依赖集 $F_{min}$
2. 观察 $U$，找出其中未在 $F_{min}$ 中出现过的属性，将其分为一个集合。
例如 $U=\{A,B,C,D,E,G\}$ ，但 $F_{min}$ 中没有关于 $G$ 的依赖关系，则单独划分出 $\{G\}$
1. 观察 $F_{min}$ ，若有多个依赖关系的决定因素（即左侧）相同，则均划分到同一个集合中。若没有相同的，则仅将该依赖关系划分到同一个集合。
例如 $F_{min}$ 中有 $\{A\rightarrow B,A\rightarrow C,D\rightarrow E\}$ 则划分出 $\{ABC\}$ 和 $\{DE\}$
1. 求出 $F_{min}$ 的候选码，若候选码未上述分类中出现，则单独将候选码分为
一类。
例如上述 $F_{min}$ 的候选码为 $ADG$，可知其未出现在各分类中，因此再划分一个集合 $\{ADG\}$。
1. 由上述举例可知，其最终的模式分解为 $\{G\},\{ABC\},\{DE\}, \{ADG\}$
#### BCNF分解
到最后也没搞懂
#### 判断是不是候选码
利用候选码的性质判断。
1. 求闭包，看闭包是否等于属性集
2. 对要判断的属性集的子集求闭包，看子集的闭包是否等于属性集，若不是则原属性集为候选码
## 事务调度
### 事务调度的准则
- 一组事务的调度必须保证：包含了所有事务的操作指令；一个事务内部的指令顺序必须保持不变
- **并行事务调度**必须保证：**可串行化**，将所有可能的串行调度结果推演一遍，对于某个具体的并行调度再执行一遍，看是否能与某个串行调度的结果相同
- 判断可串行化的充分条件：冲突可串行化（冲突可串行化一定是可串行化调度，但可串行化调度不一定是冲突可串行化）
冲突可串行化调度即不交换不同事务的冲突操作次序，也不交换同一事务的两个操作的次序。但可以交换不同事务对不同数据各种操作次序，也可以交换不同事务对同一数据的读取操作次序
### 封锁
#### X锁
写锁，某事务对数据对象上锁后，可读取和修改该数据对象，其他事务不可再对该数据对象添加锁  
表示方法：上锁Xlock()、释放锁Unlock()
#### S锁
读锁，某事务对数据对象上锁后，可读取但不可修改该数据对象，其他事务可以对该数据对象添加S锁，但不能添加X锁
表示方法：上锁Slock()、释放锁Unlock()
#### 封锁协议
##### 一级封锁协议
写前加写锁，事务结束释放写锁；可防止丢失修改
##### 二级封锁协议
写前加写锁，读前加读锁，读完释放读锁，事务结束释放写锁；可防止丢失修改和读脏数据
##### 三级封锁协议（常用：支持一致性维护）
写前加写锁，读前加读锁，事务结束释放各锁；可防止丢失修改、读脏数据和不可重复读
如果所有事务均遵循三级封锁协议，由于其隔离级别高，那么这些事务无论怎样交叉并行，都是可串性化的调度
##### 两段锁协议（2PL）
三级封锁协议可以保证并发操作的正确性，但由于其太过严苛，对并发度有负面影响。三级封锁协议实际是两段锁协议的特例，是更严格的两段锁协议。  
两段锁协议要求：事务在对任何数据进行读写前，需要获得对该数据的封锁；而当事务在释放任何一个封锁后，不可再获得任何其他封锁。**即：在最后再进行Unlock**  
**事务遵循两段锁协议是可串性化的充分条件**，遵循两段锁协议是可能发生死锁的
### 考题
#### 求串行调度结果
题目会给出两个调度 $T_1$ 、$T_2$ ,分别以$T_1$$T_2$ 和 $T_2$$T_1$ 的顺序运行调度，求出结果即可。
#### 判断并行调度是否正确
题目给出并行调度，运行之后和第一问的结果作比较，只要**和串行调度的任意一个顺序结果相同**则说明并行调度正确，否则错误。
#### 将并行调度改为遵守2PL并求出结果
先按照原调度运行，在读写操作前加锁Xlock(),此时另一调度若想进行读写操作需要wait直至运行中的调度Unlock()。
一个调度只要Unlock()一次就不能再上锁了，所以**Unlock()要放在一个调度**最后。

## E-R图（数据库设计）
### 画E-R图
- 矩形：实体集
- 双矩形：弱实体集
弱实体集没有主码，依赖于标识实体集
- 菱形：联系集
- 椭圆：属性
- 双椭圆：多值属性
- 虚椭圆：派生属性
- 双线：一个实体集全部参与到联系集中
- 一对一（1:1） 指向两边的箭头
- 一对多（1:n） 一指向多的箭头
- 多对多（m:n） 无箭头
### E-R图转换为关系模型
第一步：将各个实体的名字转换为各个关系模式的名字  
第二步：实体的属性就是关系的属性，实体的码就是关系的码  
第三步：实体间联系的转换
- 1对1联系：在任意一方加入对方的主码并设为其外码，并加入联系本身的属性
- 1对n联系：将1方的主码加入n方作为外码，并同时将联系的属性加入n方
- n对m联系：将联系本身转换为一个关系模式，将联系双方的主码加入其中设为码，并将联系的属性也加入其中